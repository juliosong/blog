---
title: "ACT2020 conference notes: Tutorial Day Lectures 4 (Paolo Perrone)"
categories: [mathematics]
tags: [category theory]
header:
  overlay_image: /assets/images/act2020-notes.jpg
  show_overlay_excerpt: false
  image_description: "a glowing red No Limit"
  caption: "Photo from [Pixabay](https://pixabay.com/illustrations/without-borders-limit-restriction-1656205/)"
  teaser: /assets/images/act2020-notes.jpg
toc: false
---

In this fourth and final lecture of the Tutorial Day, [Paolo Perrone](http://www.paoloperrone.org) teaches us what monads and comonads are with clearly presented examples. In the beginning, Paolo gave the one-line general remark that "monads are particular functors with extra structures." Then he gave out the formal definition below:
> Let $\mathcal{C}$ be a category. A monad $(T,\mu,\eta)$ on $\mathcal{C}$ involves:<br>
> 1) a functor $T:\mathcal{C}\rightarrow\mathcal{C}$,<br>
> 2) a natural transformation $\eta: 1_\mathcal{C}\Rightarrow T$ called "unit" ($\eta$ stands for "Einheit" in German), which is $C \rightarrow TC$ for $C\in\mathcal{C}$ in terms of components, and<br>
> 3) a natural transformation $\mu: TT\Rightarrow T$ called "multiplication," which is $TTC\rightarrow TC$ in terms of components,<br>
> such that for all $C\in\mathcal{C}$ the following three diagrams commute:<br>
> ![monad](/assets/images/act2020-l4-01.png)

> The idea behind monad is a way to "extend" our spaces to allow for extra outcomes, which might be more general elements or functions with more general output. (PP)

Paolo's first example was about power sets, which involved a monad in the category $\mathbf{Set}$. Specifically, given the power set functor $\mathcal{P}$, the unit $\eta$ maps a set $X$ to its power set by sending each element $x\in X$ to the singleton set $\{x\}\in\mathcal{P}X$, and the multiplication $\mu$ sends sets of subsets of $X$ to subsets of $X$ by taking union.

> $\mathcal{P}X$ extends $X$ in the sense that it is as if we can embed $X$ in $\mathcal{P}X$. We want to extend our original set because, for example, in a computer program the outcome might not be uniquely determined but could merely be a subset. (PP)

To illustrate, given a $\mathbf{Set}$-morphism $f: X\rightarrow Y$, the naturality square for $\eta$ is

![power set monad](/assets/images/act2020-l4-02.png){:width="30%"}

which commutes because for any $x\in\mathcal{C}$ we have

![power set monad commutative](/assets/images/act2020-l4-03.png){:width="40%"}

After the power set example, Paolo taught us what a Kleisli category was. Given a monad $(T, \mu, \eta)$ on $\mathcal{C}$, the objects of the Kleisli category based on the monad are just objects of $\mathcal{C}$, while the morphisms of the Kleisli category (aka "Kleisli morphisms") are defined as follows:
> $X\rightarrow Y$ is a morphism in the Kleisli category where $X\rightarrow TY$ is a morphism in $\mathcal{C}$.

An identity morphism $X\rightarrow X$ in the Kleisli category is defined by the $\mathcal{C}$-morphism $\eta: T\rightarrow TX$. And composition in the Kleisli category is defined as follows:
> for $k: X\rightarrow Y$ and $h: Y\rightarrow Z$ in the Kleisli category, namely $X\rightarrow TY$ and $Y\rightarrow TZ$ in $\mathcal{C}$, $h\circ k: X\rightarrow Z$ is defined by the $\mathcal{C}$ composition <br>
> ![Kleisli category](/assets/images/act2020-l4-04.png){:width="60%"}

Kleisli categories are useful because they define functions with generalized output and allow for extra effects like null or multiple results. In the example of power sets, the Kleisli morphisms are just set-theoretic *relations*.

The next example Paolo gave was the action/writer monad. Mathematicians like calling it the action monad, whereas computer scientists prefer the name writer monad. The definition of this monad is based on a monoid, such as the set of real numbers under addition or the set of strings generated by a set $X$ under concatenation. The monad maps $X$ to a product $X\times M$, where $M$ is an extra thing being added to the "pure outcome." And the Kleisli morphism would be $X\rightarrow Y\times M$, which sends $x\in X$ to pairs $(y,m)$ in $Y\times M$, which gives output $y$ for input $x$ **and** do something else about $y$, such as writing it to the screen or a log file.

After introducing the concept of monad, Paolo continued to introduce comonad to us. The definition of a comonad is basically the same as that of a monad, except that the arrows in (2) and (3) as well as the three commutative squares are all reversed.
> The idea behind a comonad is a way of expanding spaces to encode extra information. (PP)

Similarly, Paolo also gave us the definition of a co-Kleisli category. A co-Kleisli morphism $X\rightarrow Y$ for the comonad $C$ is a morphism $CX\rightarrow Y$, which is a "function" that depends on extra data and has access to extra information. Paolo exemplified this with the reader comonad (of $\mathbf{Set}$). Let $E$ be a fixed set (e.g., of extra data). Given any other set $X$, the "counit" maps $X\times E$ to $X$ (i.e., it puts extra data in $X$), and the "comultiplication" maps $X\times E$ to $X\times E\times E$ (i.e., it copies the extra information). And the co-Kleisli morphism is $k: X\times E\rightarrow Y$, which basically means that in order to produce the output you have to also look at the extra information (e.g., some database). Composition in this co-Kleisli category is defined as follows:
> for $k:X\times E\rightarrow Y$ and $h: Y\times E\rightarrow Z$, define $X\times E\rightarrow Z$ by the following composition:<br>
> ![co-Kleisli category](/assets/images/act2020-l4-05.png){:width="80%"}

Finally, Paolo gave another example of the string comonad. Take a monoid $(\mathbb{N},+,0)$. Then take a set $X$ and form a set of sequences from it. The comonad maps $X$ to $X^\mathbb{N} =$ {$(x_0, x_1, \dots): x_i\in X$}; namely, it keeps the trajectory or history. The counit $X^\mathbb{N}\rightarrow X$ amounts to forgetting the history, and the comultiplication $X^\mathbb{N}\rightarrow (X^\mathbb{N})^\mathbb{N}$ amounts to looking at the history of the history. The co-Kleisli morphisms based on the string comonad have access to the history. They are "maps with memory" in Paolo's words.

*References mentioned in this lecture:*
- Paolo Perrone: [Notes on category theory with examples from basic mathematics](https://arxiv.org/abs/1912.10642), Chapter 5
- Emily Rihel: [*Category Theory in Context*](http://www.math.jhu.edu/~eriehl/context.pdf), Chapter 5
- Bartosz Milewski: [*Category Theory for Programmers*](https://github.com/hmemcpy/milewski-ctfp-pdf/) + [blog](https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/)


*This is the end of my notes from the Tutorial Day.*
